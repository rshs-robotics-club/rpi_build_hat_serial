// #![allow(unused, dead_code)]
// use std::time::{Duration, Instant};

// use anyhow::{bail, Result};
// use rppal::uart::Uart;
// use thiserror::Error;
// mod errors {
//     use std::string::FromUtf8Error;
//     use thiserror::Error;

//     #[derive(Debug, Error)]
//     pub enum InitError {
//         #[error("An error with the UART socket occurred")]
//         UartError(#[from] rppal::uart::Error),
//         #[error("Failed to read from UART")]
//         ReadError(#[from] ReadError),
//         #[error("Failed to decode firmware version")]
//         FirmwareVersionDecodeError(String),
//     }
//     #[derive(Debug, Error)]
//     pub enum ReadError {
//         #[error("An error with the UART socket occurred")]
//         UartError(#[from] rppal::uart::Error),
//         #[error("There simply isn't anything to read yet")]
//         NotReady,
//         #[error("Converting from a buffer to a utf-8 string failed")]
//         UTFConversion(#[from] FromUtf8Error),
//         #[error("Read timed out")]
//         Timeout(Vec<u8>)
//     }
// }
// pub enum HatState {
//     Other,
//     Firmware,
//     NeedNewFirmware,
//     BootLoader,
// }
// pub struct BuildHatSerial {
//     ser: Uart,
//     state: HatState,
// }
// impl BuildHatSerial {
//     /// Create a new [`BuildHatSerial`]
//     ///
//     /// Only one [`BuildHatSerial`] should exist at a time; e.g. this function should only be called once.
//     pub fn new(device: Option<String>, version: &str) -> Result<Self, errors::InitError> {
//         let device = device.unwrap_or("/dev/serial0".to_string());
//         let mut ser = Uart::with_path(device, 115200, rppal::uart::Parity::None, 8, 1)?;
//         ser.set_read_mode(0, Duration::ZERO)?;
//         let mut hat = Self {
//             ser,
//             state: HatState::Other,
//         };
//         // do a bootloader/firmware check? personally i'm not certain what this is for.
//         hat.write("version\r".as_bytes())?;
//         // a counter that breaks the loop once it reaches 3?
//         let mut empty_data = 0;
//         // a counter that counts the number of times we get data we can't understand.
//         let mut rand_data_counter = 0;

//         loop {
//             let line = hat.readline(Duration::from_millis(5));
//             if let Ok(reply) = line {
//                 if reply.contains("Firmware version: ") {
//                     // hat.state = HatState::Firmware;
//                     let version = &reply["Firmware version: ".len()..].split(' ');
//                     let ver_first_split = version
//                         .next()
//                         .ok_or(errors::InitError::FirmwareVersionDecodeError(reply))?;
//                     if ver_first_split == version {
//                         hat.state = HatState::Firmware;
//                     } else {
//                         hat.state = HatState::NeedNewFirmware;
//                     }
//                 } else if reply.contains("BuildHAT bootloader version") {
//                     hat.state = HatState::BootLoader;
//                 } else {
//                     rand_data_counter += 1;
//                     if rand_data_counter > 5 {
//                         break;
//                     } else {
//                         hat.write("version\r".as_bytes());
//                     }
//                 }
//             } else if let Err(err) = line {
//                 match err {
//                     errors::ReadError::NotReady => {
//                         empty_data += 1;
//                         if empty_data > 3 {
//                             break;
//                         }
//                     }
//                     _ => return Err(err),
//                 }
//             }
//         }
//         todo!();
//         Ok(hat)
//     }
//     /// Write some data through the serial port. Use other functions for sending data.
//     pub fn write(&mut self, data: &[u8]) -> Result<usize, rppal::uart::Error> {
//         self.ser.write(data)
//     }
//     /// Read some data as a utf-8 encoded string.
//     ///
//     /// Returns [`errors::ReadError::NotReady`] if not ready. This function is non-blocking.
//     /// There is no guarantee whether the string conversion succeeds.
//     pub fn read(&mut self) -> Result<String, errors::ReadError> {
//         let mut read_buffer = [0u8; 255];
//         let read_len = self.ser.read(&mut read_buffer)?;
//         if read_len == 0 {
//             Err(errors::ReadError::NotReady)
//         } else {
//             Ok(String::from_utf8(read_buffer.to_vec())?.trim().to_string())
//         }
//     }
//     /// Read a single line
//     pub fn readline(&mut self, timeout: Duration) -> Result<String, errors::ReadError> {
//         let mut complete_buffer = [0u8; 255];
//         let mut complete_buffer_index = 0;
//         let mut read_buffer = ['@' as u8; 255];
//         let time_start = Instant::now();
//         loop {
//             let read_len = self.ser.read(&mut read_buffer)?;
//             if read_len == 0 {
//                 continue;
//             }
//             for (index, byte) in read_buffer.iter().enumerate() {
//                 if byte == '@' {
//                     // end of buffer
//                     let meaningful_buffer = &read_buffer[0..index];
//                     // attach the meaningful bit to the complete buffer
//                     complete_buffer[complete_buffer_index..(index + complete_buffer_index)]
//                         .copy_from_slice(meaningful_buffer);
//                     complete_buffer_index += index;
//                 }
//             }
//             if complete_buffer[complete_buffer_index] == '\n' {
//                 // end of line reached
//                 let s = String::from_utf8(complete_buffer.to_vec())?;
//                 return Ok(s);
//             }
//             if (Instant::now() - time_start) > timeout {
//                 // escape hatch
//                 return Err(errors::ReadError::Timeout(complete_buffer.to_vec()));
//             }
//         }
//     }
//     /// Calculates a checksum for some data.
//     ///
//     /// This function is used for loading firmware.
//     pub fn checksum(data: &[u8]) -> u32 {
//         let mut u: u32 = 1;
//         for &byte in data {
//             if (u & 0x80000000) != 0 {
//                 u = (u << 1) ^ 0x1d872b41;
//             } else {
//                 u <<= 1;
//             }
//             u = (u ^ u32::from(byte)) & 0xFFFFFFFF;
//         }
//         u
//     }
// }
